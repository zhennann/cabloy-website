# 角色

Cabloy的角色体系不同于网上流行的`RBAC模型`。

> `RBAC模型`没有解决业务开发中`资源范围授权`的问题。比如，Mike是软件部的员工，只能查看自己的日志；Jone是软件部经理，可以查看本部门的日志；Jimmy是企业负责人，可以查看整个企业的日志。

> `RBAC模型`概念复杂，在实际应用中，又往往引入新的概念，使得角色体系难以理解和维护。

## 概念辨析

涉及到角色体系，往往会有这些概念：用户、用户组、角色、部门、岗位、资源等等。而Cabloy设计的角色体系只有用户、角色、原子类型等概念，概念精简，层次清晰，灵活高效，既便于理解，又便于维护。

`内置角色`树

- root
  - anonymous
  - authenticated
    - registered
    - activated
    - superuser
    - organization
      - internal
      - external

> 1. 部门即角色: 部门其实就是角色，因为部门下面还有子角色，Cabloy把这种部门角色称为`目录角色`
> 2. 岗位即角色: 岗位其实也是角色，Cabloy把岗位角色称为`子角色`，只有`子角色`才允许添加`用户`
> 3. 授权范围即角色: 为了实现`资源范围授权`的特性，只需要在授权记录中指定某个角色即可

## 角色授权传递

Cabloy中的角色授权有两种传递机制：

1. 继承传递(纵向): 角色的授权会自动被其子角色继承。比如，角色`organization`自动拥有角色`authenticated`的授权
2. 聚合传递(横向): 角色可以聚合另一个角色从而拥有改角色的授权。比如，如果角色`superuser`聚合了角色`activated`，那么就拥有角色`activated`的授权。同样，根据`继承传递`机制，角色`superuser`的所有子角色也自动拥有角色`activated`的授权

## 角色结构重建

为了提升运行性能，Cabloy依据`继承`和`聚合`两种传递机制，对角色进行展开处理。所以，如果修改了任何与角色结构相关的数据，就需要执行`角色结构重建`，从而使角色生效。

`查询角色结构状态`
```javascript
const dirty=await this.ctx.meta.role.getDirty();
```

`角色结构重建`
```javascript
await this.ctx.meta.role.build();
```
